\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}

\setlength{\parindent}{0pt} % no identation

%
\title{Survey: Lattice Reduction techniques to attack RSA}
\author{David Wong}
\date{March 2015}

%
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{theorem}{Theorem}


\begin{document}

\maketitle

\begin{abstract}
\textbf{RSA}, carrying the names of \textbf{Ron Rivest}, \textbf{Adi Shamir} and \textbf{Leonard Adleman}, is one of the first practicable \textbf{public-key} cryptosystem. The algorithm was publicly described for the first time in \textbf{1977} and has since been since the most used cryptosystem when it comes to asymmetric problems. For now more than \textbf{30 years}, Cryptanalists and Researchers have looked for ways to \textbf{attack RSA}.\\
In 1995, \textbf{Coppersmith} released a paper on how to attack RSA using \textbf{Lattices} and \textbf{Lattice reduction techniques} such as \textbf{LLL}. A few years later, \textbf{Howgrave-Graham} revisited Coppersmith's algorithm and made it easier to understand and apply.\\
Attacks based on Lattice reduction techniques caught up and several researches were done on the subject. Years after \textbf{Wiener} found that you could successfully break RSA if the private exponent was too small. In 2000, \textbf{Boneh} and \textbf{Durfee} found a better attack, still based on Lattice, that was simplified afterwards by a work from \textbf{Herrmann} and \textbf{Mayers}.\\
In the 1st and 2nd sections of this survey I will briefly explain how RSA and Lattice work. In section 3 we will see in what \textbf{model} the attacks are taking place. Section 4 will be an overview of the Coppersmith attack revisited by Howgrave-Graham. Section 5 will be an overview of the Boneh and Durfee attack revisited by Herrmann and May. Finally we will see \textbf{some applications} of those attacks.
\end{abstract}

\newpage

\section{RSA}\label{rsa}

Let's quickly recall \textbf{what is} and \textbf{how} RSA works:\\
RSA is an \textbf{asymmetric cryptosystem}. A generator algorithm derives two kind of keys: a \textbf{public key} and a \textbf{private key}, these can be swapped around thanks to the asymmetric property of RSA to allow us to use the system as an \textbf{encryption} system or as a \textbf{signature} system.\\

\subsection{Generation}

To use RSA we need a public key to encrypt and a private key to decrypt. We first generate the public key pair as follow:\\

We generate $p, q$ \textbf{primes}. For security issues they should be around the \textbf{same size}. Those primes are the \textbf{core elements} of RSA. Knowing one of those allows us to compute the private key, thus allowing us to break the system. They can also be used to speed up calculations using the Chinese Remainder Theorem. We will see all about that later.\\
Knowing $p$ and $q$ we can then compute the \textbf{modulus} $N = p \times q$ which will be part of the public key as well as the private key. And you will see why.\\

Now comes the interesting part, we need to find a \textbf{public exponent} which will be used for \textbf{encryption}. For computation purpose a \textbf{Fermat prime} ($2^{m} + 1$) is often used as public exponent (it makes things faster in \textbf{binary exponentiation}). In the case of a \textbf{signature scheme}, we would want the speed up to occur for the \textbf{private exponent} so we would use such a number as a private exponent and we would reverse the following steps.\\
Anyway, any kind of exponent can theoretically be chosen, as long as it is coprime with $\varphi(N)$ (The \textbf{Euler's Totient function}).

\[e \leftarrow \mathbb{Z}_{\varphi(N)}^{\ast}\]

if $e$ is \textbf{coprime} with $\varphi(N)$ then it is part of the multiplicative group $(\mathbb{Z}/\varphi(N)\mathbb{Z})^{\ast}$ and thus \textbf{invertible} in $\mathbb{Z}/\varphi(N)\mathbb{Z}$.\\

Now it is pretty easy to find the private exponent $d$ by inverting our public exponent $e$.\\

All of this is possible because we can easily compute $\varphi(N)$:

\[\varphi(N) = (p - 1) \times (q - 1)\]

And here resides the \textbf{security} of RSA. Imagine for a moment that we could easily factor $N$ into $p$ and $q$, then we would be able to invert the public exponent $e$. That's why we say that \textbf{the security of RSA is reduced to the Factorization Problem}.\\

Now let the \textbf{private key} be $\textbf{(N, d)}$ with the addition of $(p, q)$ if we need to speed up calculations.
And let the \textbf{public key} be $\textbf{(N, e)}$.

\subsection{Encryption/Decryption}

To \textbf{encrypt} a message $m$, with $m < N$ we just do:
\[ c = m^e \pmod{N} \]

And to \textbf{decrypt}:
\[ m = c^d \pmod{N} \]\\


This works because the decryption step gives us:
\[ c^d = (m^e)^d \pmod{N} \]

And $e$ being $d$'s inverse tells us that:

\begin{align*}
	&e = d^{-1} \pmod{\varphi(N)} \\
	\implies& ed = 1 \pmod{\varphi(N)} \\
	\implies& ed = \varphi(N) + 1
\end{align*}

Coupled with \textbf{Euler's Theorem} stating that if $a$ and $n$ are coprime then:
\[ a^{\varphi(n)} = 1 \pmod{n} \]

Tells us that $m^{ed} = m \pmod{N}$

\section{Lattice}\label{lattice}

\subsection{Introduction}
The attacks we will describe later both make use of the \textbf{Lenstra–Lenstra–Lovász lattice basis reduction algorithm}. Hence it is necessary for us to understand what is a lattice and why is this \textbf{LLL} algorithm so useful.\\
Think about Lattices like \textbf{Vector Spaces}. Imagine a simple vector space of two vectors. You can add them together, multiply them by scalars (let's say numbers of $\mathbb{R}$) and it spans a vector space.

\begin{tikzpicture}[scale=.5]
\draw [lightgray] [<->] (0,5) -- (10,5);
\draw [lightgray] [<->] (5,10) -- (5,0);
\draw [thick,purple] [->] (5,5) -- (6, 8);
\draw [thick,purple] [->] (5,5) -- (6, 6);

\draw [thick,black] [->] (11,5) -- (12,5);

\draw [lightgray] [<->] (13,5) -- (23,5);
\draw [lightgray] [<->] (18,10) -- (18,0);
%\path [fill=purple] (18,5) to (20.5,10) to (23,10) to (18,5);
\path [fill=purple] (15.5,0) to (20.5,10) to (23,10) to (13,0);
\end{tikzpicture}\\

Now imagine that our vector space's \textbf{scalars are the integers}, taken in $\mathbb{Z}$. The space spanned by the vectors is now made out of points. It's \textbf{discrete}. Meaning that for any point of this lattice there is a ball centered around that point of radius different from zero that contains only that point. Nothing else.\\
\begin{figure}[!h]
\centering
\begin{tikzpicture}[scale=.5]
\draw [lightgray] [<->] (0,5) -- (10,5);
\draw [lightgray] [<->] (5,10) -- (5,0);

\draw [fill,purple] (9,1) circle [radius=0.1];

\draw [fill,purple] (7,1) circle [radius=0.1];
\draw [fill,purple] (8,2) circle [radius=0.1];
\draw [fill,purple] (9,3) circle [radius=0.1];

\draw [fill,purple] (5,1) circle [radius=0.1];
\draw [fill,purple] (6,2) circle [radius=0.1];
\draw [fill,purple] (7,3) circle [radius=0.1];
\draw [fill,purple] (8,4) circle [radius=0.1];
\draw [fill,purple] (9,5) circle [radius=0.1];

\draw [fill,purple] (3,1) circle [radius=0.1];
\draw [fill,purple] (4,2) circle [radius=0.1];
\draw [fill,purple] (5,3) circle [radius=0.1];
\draw [fill,purple] (6,4) circle [radius=0.1];
\draw [fill,purple] (7,5) circle [radius=0.1];
\draw [fill,purple] (8,6) circle [radius=0.1];
\draw [fill,purple] (9,7) circle [radius=0.1];

\draw [fill,purple] (1,1) circle [radius=0.1];
\draw [fill,purple] (2,2) circle [radius=0.1];
\draw [fill,purple] (3,3) circle [radius=0.1];
\draw [fill,purple] (4,4) circle [radius=0.1];
\draw [fill,purple] (5,5) circle [radius=0.1];
\draw [fill,purple] (6,6) circle [radius=0.1];
\draw [fill,purple] (7,7) circle [radius=0.1];
\draw [fill,purple] (8,8) circle [radius=0.1];
\draw [fill,purple] (9,9) circle [radius=0.1];

\draw [fill,purple] (1,3) circle [radius=0.1];
\draw [fill,purple] (2,4) circle [radius=0.1];
\draw [fill,purple] (3,5) circle [radius=0.1];
\draw [fill,purple] (4,6) circle [radius=0.1];
\draw [fill,purple] (5,7) circle [radius=0.1];
\draw [fill,purple] (6,8) circle [radius=0.1];
\draw [fill,purple] (7,9) circle [radius=0.1];

\draw [fill,purple] (1,5) circle [radius=0.1];
\draw [fill,purple] (2,6) circle [radius=0.1];
\draw [fill,purple] (3,7) circle [radius=0.1];
\draw [fill,purple] (4,8) circle [radius=0.1];
\draw [fill,purple] (5,9) circle [radius=0.1];

\draw [fill,purple] (1,7) circle [radius=0.1];
\draw [fill,purple] (2,8) circle [radius=0.1];
\draw [fill,purple] (3,9) circle [radius=0.1];

\draw [fill,purple] (1,9) circle [radius=0.1];
\end{tikzpicture}
\end{figure}

Lattice are interesting in cryptography because we seldom deal with real numbers and they bring us a lot of tools to deal with integers.

Just as vector spaces, lattices can also be described by different basis represented as \textbf{matrices}. Contrary to vector spaces, we generally represent the vectors of the basis as \textbf{rows} in their corresponding matrices.\\

Last but not least, if $\{\tilde{b}_1\,\hdots,\tilde{b}_w\}$ are the vectors of the Gram-Schmidt basis of a lattice $L$ then we define the \textbf{determinant} of the lattice as such:

\[ det(L) := \prod_{i=1}^{w} \|\tilde{b}_i\| \]

\subsection{LLL}

The \textbf{Lenstra–Lenstra–Lovász} \textit{lattice basis reduction algorithm} is a step by step calculus that reduces a lattice basis in polynomial time. The lattice is left unchanged but the row vectors of its new basis are ``\textbf{smaller}'' according to some definitions:

\begin{definition}
Let $L$ be a lattice with a basis $B$. The $\delta$-LLL algorithm applied on $L$'s basis $B$ produces a new basis of $L$: $B' = \{b_1,\hdots,b_n\}$ satisfying:
\begin{eqnarray}
\forall \hspace{1mm} 1 \leq j < i \leq n \text{ we have } |\mu_{i,j}| \leq \frac{_1}{^2}\\
\forall \hspace{1mm} 1 \leq i < n \text{ we have } \delta \cdot \|\tilde{b_i}\|^2 \leq \| \mu_{i+1,i}\cdot \tilde{b}_i + \tilde{b}_{i + 1}\|^2
\end{eqnarray}
\begin{center}
with $\mu_{i,j} = \frac{b_i \cdot \tilde{b}_j}{\tilde{b}_j \cdot \tilde{b}_j}$ and $\tilde{b}_1 = b_1$ (Gram-Schmidt)
\end{center}
\end{definition}

We will not see dig into the interals of LLL here, see Chris Peikert's course\cite{chrispeikert} for a detailed view of the algorithm.

\subsection{Wanted properties of LLL}

LLL yields an approximation of the \textbf{Shortest Vector Problem}. This is useful for us because if we consider the row vectors of a lattice's basis as \textbf{coefficient vectors of polynomials}. We can find a \textbf{linear combination} of those polynomials that has \textbf{``particularly small'' coefficients}. But let's not unveil too much too soon. Here are some relevant properties of a LLL reduced basis that we will need later:


\begin{property}
Let $\{b_1,\hdots,b_n\}$ be a $\delta$-LLL-reduced basis for a lattice $L$ in $\mathbb{R}^n$, and let $\tilde{b_1},\hdots,\tilde{b_n}$ be the Gram-Schmidt basis. Then we have

\begin{align*}
 &\|b_j\|^2 \leq 2^{i-1} \cdot \|\tilde{b}_i\|^2 \hspace{10mm}\text{ for } 1 \leq j \leq i \leq n \\
 &\|\tilde{b_1}\| \leq 2^{\frac{n-1}{4}} \cdot det(L)^{\frac{1}{n}} 
\end{align*}
\end{property}

\begin{property}
Let $L \in \mathbb{Z}^n$ be a lattice spanned by $B = \{b_1, \hdots, b_n\}$. The LLL algorithm outputs a reduced lattice basis $\{v_1,\hdots,v_n\}$ with

\[ \|v_i\| \leq 2^{\frac{n(n-1)}{4(n-i+1)}} \cdot det(L)^{\frac{1}{n-i+1}} \hspace{5mm} \text{ for } i = 1,\hdots,n\]

in time polynomial in $n$ and in the bit-size of the entries of the basis matrix $B$.
\end{property}


\section{Attacks}\label{attacks}

Attacks on RSA falls into two categories: the attacks on the \textbf{implementation} or the \textbf{mathematical attacks}. Over the years the mathematical cryptanalysis has proven to be hard and thus the cryptosystem is still considered as secure nowadays (march 2015). But what a researcher could find interesting is to attack a \textbf{relaxed} version of the RSA problem. What if we knew ``a part'' of the message, or what if we knew ``an approximation'' of one of the prime, or what if the private exponent was ``too small''...

% As an example let's see the simple Hadstad broadcast attack:

% Hadstad Broadcast Attack

% But what if m was not small, but we know m up to a small part

\section{Coppersmith}\label{coppersmith}

This survey is no replacement for the original papers of Coppersmith\cite{coppersmith} and Howgrave-Graham\cite{howgrave-graham}. If you want to get a real understanding of those techniques I also advise you to read the survey from May\cite{may}.

That being said, let's dig into Coppersmith's use of LLL to crack RSA. We'll first see one of the problem it solves and build it from there. Imagine that you know a part of the message: this is called the \textbf{Stereotyped Messages Attack}. For example you know that the Alice always sends her messages this way: ``the password is: cupcake''.

Let's say we know $m_0$ of the message $m = m_0 + x$. And of course we don't know $x$. We have \textbf{our problem} translated to the following equation:

\[ f(x) = (m_0 + x)^e - c = 0 \pmod{N} \]

Well. \textbf{Coppersmith} says we can solve this if $x$ and $e$ are small enough:

\begin{theorem}
Let $N$ be an integer of unknown factorization, which has a divisor $b \geq N^{\beta}$, $0 < \beta \leq 1$. Let $f(x)$ be a univariate monic polynomial of degree $\delta$ and let $c \geq 1$.\\
Then we can find in time $\mathcal{O}(c\delta^5log^9(N))$ all solutions $x_0$ of the equation

\[ f(x) = 0 \pmod{b} \hspace{2mm} \text{ with } \hspace{2mm} |x_0| \leq c \cdot N^{\frac{\beta^2}{\delta}} \]
\end{theorem}

In our case that would mean that for $c=1$ and $beta=1$ we could find a solution of our previous equation if $|x_0| \leq N^{\frac{1}{e}}$. And here we find something very similar to Håstad's Broadcast Attack.

To find the root of a polynomial over the integers we possess efficient algorithms, but to find a root over a ring of integers modulo $N$ is a different story.
But here's the trick, reformulated by \textbf{Howgrave-Graham}:

\begin{theorem}
Let $g(x)$ be an univariate polynomial with $n$ monomials. Further, let $m$ be a positive integer. Suppose that
\setcounter{equation}{0}
\begin{align}
&g(x_0) = 0 \pmod{b}^m \hspace{2mm} \text{ where } \hspace{2mm} |x_0| \leq X\\
&\|g(xX)\| < \frac{_{b^m}}{^{\sqrt{n}}}
\end{align}

Then $g(x_0)=0$ holds over the integers.
\end{theorem}

What Howgrave-Graham is saying is that we need to \textbf{find a polynomial} that shares the same root as our function $f$ but modulo $N^m$ and it has to have \textbf{``small'' coefficients} so that its norm would be ``small'' as well.\\

\begin{tikzpicture}
\node [above] at (2,4) {$f(x_0) = 0 \pmod{N}$ with $|x_0| < X$};
\draw [<-] (0,0) -- (0,4);
\node [below] at (0.6,0) {$g(x_0) = 0$ over $\mathbb{Z}$};
\draw [purple,<-] (0,1) -- (1,1);
\node [right] at (1.2,1.35) {$g(x_0) = 0 \pmod{N^m}$};
\node [right] at (1.2,.65) {$\|g(xX)\| < \frac{N^m}{sqrt{n}}$};
\draw [purple,<-] (3,2) -- (3,4);
\draw [purple,<-] (0,0) -- (0,1);

\end{tikzpicture}

Howgrave-Graham's idea is that we need to find this $g$ through a \textbf{linear combination} of polynomials who have $x_0$ as roots, and the more polynomials we can play with, the better it is. We will see now that it's very easy for us to create polynomials $f_i$ such that $f_i(x_0) = 0 \pmod{N^m}$. And that is the reason why we choose to find a polynomial over $N^m$ and not over $N$.

The \textbf{LLL reduction} has the property that it only does \textbf{linear operations} on the basis vectors, which is what we want, and the \textbf{shortest vector of the output basis is bound} (as seen in \textbf{Property 1}).

Now if we could control that upper bound so that we obtain Howgrave-Graham's second property on the shortest vector of the new basis, it would work. The \textbf{upper bound} is a function of the dimension and the determinant as seen bellow:

\[ \|b_1\| < 2^{\frac{n-1}{4}} \cdot det(L)^{\frac{1}{n}} \]

But first let's see how to \textbf{build the polynomials} we will use to fill the first lattice basis with:

\begin{align*}
	g_{i,j}(x) &= x^j \cdot N^i \cdot f^{m-i}(x) \text{ for } i = 0,\hdots,m-1, j=0,\hdots,\delta-1\\
	h_i(x) &= x^i \cdot f^m(x) \text{ for } i = 0,\hdots,t-1
\end{align*}

\section{Boneh-Durfee}\label{bonehdurfee}

This survey is no replacement for the original papers of Boneh and Durfee\cite{bonehdurfee} and Herrmann and May\cite{herrmannmay}.

We've seen how Coppersmith found a way of using lattices and the LLL algorithm to find small roots to particular univariate polynomials. What about problems that have two unknowns? Coppersmith gave an heuristic for finding roots of bivariate polynomials, Wiener as well, but in this survey we will focus on Boneh and Durfee.



\newpage
\begin{thebibliography}{1}

\bibitem{chrispeikert} Chris Peikert {\em Lattices in Cryptography, Georgia Tech, Fall 2013: Lecture 2, 3}
\bibitem{coppersmith} Don Coppersmith {\em Finding Small Solutions to Small Degree Polynomials}
\bibitem{howgrave-graham} Nicholas Howgrave-Graham {\em Finding Small Roots of Univariate Modular Equations Revisited}
\bibitem{may} Alexander May {\em Using LLL-Reduction for Solving RSA and Factorization Problems}
\bibitem{bonehdurfee} Boneh and Durfee {\em Cryptanalysis of RSA with Private Key d Less Than $N^{0.292}$}
\bibitem{herrmannmay} Herrmann and May {\em Maximizing Small Root Bounds by Linearization and Applications to Small Secret Exponent RSA}


\end{thebibliography}

\end{document}