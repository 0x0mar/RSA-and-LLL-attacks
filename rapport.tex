\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}

\setlength{\parindent}{0pt} % no identation

%
\title{Survey: Lattice Reduction techniques to attack RSA}
\author{David Wong}
\date{March 2015}

%
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{theorem}{Theorem}


\begin{document}

\maketitle

\begin{abstract}
\textbf{RSA}, carrying the names of \textbf{Ron Rivest}, \textbf{Adi Shamir} and \textbf{Leonard Adleman}, is one of the first practicable \textbf{public-key} cryptosystem. The algorithm was publicly described for the first time in \textbf{1977} and has since been since the most used cryptosystem when it comes to asymmetric problems. For now more than \textbf{30 years}, Cryptanalists and Researchers have looked for ways to \textbf{attack RSA}.\\
In 1995, \textbf{Coppersmith} released a paper on how to attack RSA using \textbf{Lattices} and \textbf{Lattice reduction techniques} such as \textbf{LLL}. A few years later, \textbf{Howgrave-Graham} revisited Coppersmith's algorithm and made it easier to understand and apply.\\
Attacks based on Lattice reduction techniques caught up and several researches were done on the subject. Years after \textbf{Wiener} found that you could successfully break RSA if the private exponent was too small. In 2000, \textbf{Boneh} and \textbf{Durfee} found a better attack, still based on Lattice, that was simplified afterwards by a work from \textbf{Herrmann} and \textbf{Mayers}.\\
In the 1st and 2nd sections of this survey I will briefly explain how RSA and Lattice work. In section 3 we will see in what \textbf{model} the attacks are taking place. Section 4 will be an overview of the Coppersmith attack revisited by Howgrave-Graham. Section 5 will be an overview of the Boneh and Durfee attack revisited by Herrmann and May. Finally we will see \textbf{some applications} of those attacks.
\end{abstract}

\newpage

\section{RSA}\label{rsa}

Let's quickly recall \textbf{what is} and \textbf{how} RSA works:\\
RSA is an \textbf{asymmetric cryptosystem}. A generator algorithm derives two kind of keys: a \textbf{public key} and a \textbf{private key}, these can be swapped around thanks to the asymmetric property of RSA to allow us to use the system as an \textbf{encryption} system or as a \textbf{signature} system.\\

\subsection{Generation}

To use RSA we need a public key to encrypt and a private key to decrypt. We first generate the public key pair as follow:\\

We generate $p, q$ \textbf{primes}. For security issues they should be around the \textbf{same size}. Those primes are the \textbf{core elements} of RSA. Knowing one of those allows us to compute the private key, thus allowing us to break the system. They can also be used to speed up calculations using the Chinese Remainder Theorem. We will see all about that later.\\
Knowing $p$ and $q$ we can then compute the \textbf{modulus} $N = p \times q$ which will be part of the public key as well as the private key. And you will see why.\\

Now comes the interesting part, we need to find a \textbf{public exponent} which will be used for \textbf{encryption}. For computation purpose a \textbf{Fermat prime} ($2^{m} + 1$) is often used as public exponent (it makes things faster in \textbf{binary exponentiation}). In the case of a \textbf{signature scheme}, we would want the speed up to occur for the \textbf{private exponent} so we would use such a number as a private exponent and we would reverse the following steps.\\
Anyway, any kind of exponent can theoretically be chosen, as long as it is coprime with $\varphi(N)$ (The \textbf{Euler's Totient function}).

\[e \leftarrow \mathbb{Z}_{\varphi(N)}^{\ast}\]

if $e$ is \textbf{coprime} with $\varphi(N)$ then it is part of the multiplicative group $(\mathbb{Z}/\varphi(N)\mathbb{Z})^{\ast}$ and thus \textbf{invertible} in $\mathbb{Z}/\varphi(N)\mathbb{Z}$.\\

Now it is pretty easy to find the private exponent $d$ by inverting our public exponent $e$.\\

All of this is possible because we can easily compute $\varphi(N)$:

\[\varphi(N) = (p - 1) \times (q - 1)\]

And here resides the \textbf{security} of RSA. Imagine for a moment that we could easily factor $N$ into $p$ and $q$, then we would be able to invert the public exponent $e$. That's why we say that \textbf{the security of RSA is reduced to the Factorization Problem}.\\

Now let the \textbf{private key} be $\textbf{(N, d)}$ with the addition of $(p, q)$ if we need to speed up calculations.
And let the \textbf{public key} be $\textbf{(N, e)}$.

\subsection{Encryption/Decryption}

To \textbf{encrypt} a message $m$, with $m < N$ we just do:
\[ c = m^e \pmod{N} \]

And to \textbf{decrypt}:
\[ m = c^d \pmod{N} \]\\


This works because the decryption step gives us:
\[ c^d = (m^e)^d \pmod{N} \]

And $e$ being $d$'s inverse tells us that:

\begin{align*}
	&e = d^{-1} \pmod{\varphi(N)} \\
	\implies& ed = 1 \pmod{\varphi(N)} \\
	\implies& ed = \varphi(N) + 1
\end{align*}

Coupled with \textbf{Euler's Theorem} stating that if $a$ and $n$ are coprime then:
\[ a^{\varphi(n)} = 1 \pmod{n} \]

Tells us that $m^{ed} = m \pmod{N}$

\section{Lattice}\label{lattice}

\subsection{Introduction}
The attacks we will describe later both make use of the \textbf{Lenstra–Lenstra–Lovász lattice basis reduction algorithm}. Hence it is necessary for us to understand what is a lattice and why is this \textbf{LLL} algorithm so useful.\\
Think about Lattices like \textbf{Vector Spaces}. Imagine a simple vector space of two vectors. You can add them together, multiply them by scalars (let's say numbers of $\mathbb{R}$) and it spans a vector space.

\begin{tikzpicture}[scale=.5]
\draw [lightgray] [<->] (0,5) -- (10,5);
\draw [lightgray] [<->] (5,10) -- (5,0);
\draw [thick,purple] [->] (5,5) -- (6, 8);
\draw [thick,purple] [->] (5,5) -- (6, 6);

\draw [thick,black] [->] (11,5) -- (12,5);

\draw [lightgray] [<->] (13,5) -- (23,5);
\draw [lightgray] [<->] (18,10) -- (18,0);
%\path [fill=purple] (18,5) to (20.5,10) to (23,10) to (18,5);
\path [fill=purple] (15.5,0) to (20.5,10) to (23,10) to (13,0);
\end{tikzpicture}\\

Now imagine that our vector space's \textbf{scalars are the integers}, taken in $\mathbb{Z}$. The space spanned by the vectors is now made out of points. It's \textbf{discrete}. Meaning that for any point of this lattice there is a ball centered around that point of radius different from zero that contains only that point. Nothing else.

\begin{figure}[!h]
\centering
\begin{tikzpicture}[scale=.5]
\draw [lightgray] [<->] (0,5) -- (10,5);
\draw [lightgray] [<->] (5,10) -- (5,0);

\draw [fill,purple] (9,1) circle [radius=0.1];

\draw [fill,purple] (7,1) circle [radius=0.1];
\draw [fill,purple] (8,2) circle [radius=0.1];
\draw [fill,purple] (9,3) circle [radius=0.1];

\draw [fill,purple] (5,1) circle [radius=0.1];
\draw [fill,purple] (6,2) circle [radius=0.1];
\draw [fill,purple] (7,3) circle [radius=0.1];
\draw [fill,purple] (8,4) circle [radius=0.1];
\draw [fill,purple] (9,5) circle [radius=0.1];

\draw [fill,purple] (3,1) circle [radius=0.1];
\draw [fill,purple] (4,2) circle [radius=0.1];
\draw [fill,purple] (5,3) circle [radius=0.1];
\draw [fill,purple] (6,4) circle [radius=0.1];
\draw [fill,purple] (7,5) circle [radius=0.1];
\draw [fill,purple] (8,6) circle [radius=0.1];
\draw [fill,purple] (9,7) circle [radius=0.1];

\draw [fill,purple] (1,1) circle [radius=0.1];
\draw [fill,purple] (2,2) circle [radius=0.1];
\draw [fill,purple] (3,3) circle [radius=0.1];
\draw [fill,purple] (4,4) circle [radius=0.1];
\draw [fill,purple] (5,5) circle [radius=0.1];
\draw [fill,purple] (6,6) circle [radius=0.1];
\draw [fill,purple] (7,7) circle [radius=0.1];
\draw [fill,purple] (8,8) circle [radius=0.1];
\draw [fill,purple] (9,9) circle [radius=0.1];

\draw [fill,purple] (1,3) circle [radius=0.1];
\draw [fill,purple] (2,4) circle [radius=0.1];
\draw [fill,purple] (3,5) circle [radius=0.1];
\draw [fill,purple] (4,6) circle [radius=0.1];
\draw [fill,purple] (5,7) circle [radius=0.1];
\draw [fill,purple] (6,8) circle [radius=0.1];
\draw [fill,purple] (7,9) circle [radius=0.1];

\draw [fill,purple] (1,5) circle [radius=0.1];
\draw [fill,purple] (2,6) circle [radius=0.1];
\draw [fill,purple] (3,7) circle [radius=0.1];
\draw [fill,purple] (4,8) circle [radius=0.1];
\draw [fill,purple] (5,9) circle [radius=0.1];

\draw [fill,purple] (1,7) circle [radius=0.1];
\draw [fill,purple] (2,8) circle [radius=0.1];
\draw [fill,purple] (3,9) circle [radius=0.1];

\draw [fill,purple] (1,9) circle [radius=0.1];
\end{tikzpicture}
\end{figure}

Lattice are interesting in cryptography because we seldom deal with real numbers and they bring us a lot of tools to deal with integers.

Just as vector spaces, lattices can also be described by different basis represented as \textbf{matrices}. Contrary to vector spaces, we generally represent the vectors of the basis as \textbf{rows} in their corresponding matrices.\\

Last but not least, if $\{\tilde{b}_1\,\hdots,\tilde{b}_w\}$ are the vectors of the Gram-Schmidt basis of a lattice $L$ then we define the \textbf{determinant} of the lattice as such:

\[ det(L) := \prod_{i=1}^{w} \|\tilde{b}_i\| \]

\subsection{LLL}

The \textbf{Lenstra–Lenstra–Lovász} \textit{lattice basis reduction algorithm} is a step by step calculus that reduces a lattice basis in polynomial time. The lattice is left unchanged but the row vectors of its new basis are ``\textbf{smaller}'' according to some definitions:

\begin{definition}
Let $L$ be a lattice with a basis $B$. The $\delta$-LLL algorithm applied on $L$'s basis $B$ produces a new basis of $L$: $B' = \{b_1,\hdots,b_n\}$ satisfying:
\begin{eqnarray}
\forall \hspace{1mm} 1 \leq j < i \leq n \text{ we have } |\mu_{i,j}| \leq \frac{_1}{^2}\\
\forall \hspace{1mm} 1 \leq i < n \text{ we have } \delta \cdot \|\tilde{b_i}\|^2 \leq \| \mu_{i+1,i}\cdot \tilde{b}_i + \tilde{b}_{i + 1}\|^2
\end{eqnarray}
\begin{center}
with $\mu_{i,j} = \frac{b_i \cdot \tilde{b}_j}{\tilde{b}_j \cdot \tilde{b}_j}$ and $\tilde{b}_1 = b_1$ (Gram-Schmidt)
\end{center}
\end{definition}

We will not see dig into the interals of LLL here, see Chris Peikert's course\cite{chrispeikert} for a detailed view of the algorithm.

\subsection{Wanted properties of LLL}

LLL yields an approximation of the \textbf{Shortest Vector Problem}. This is useful for us because if we consider the row vectors of a lattice's basis as \textbf{coefficient vectors of polynomials}. We can find a \textbf{linear combination} of those polynomials that has \textbf{``particularly small'' coefficients}. But let's not unveil too much too soon. Here are some relevant properties of a LLL reduced basis that we will need later:


\begin{property}
Let $\{b_1,\hdots,b_n\}$ be a $\delta$-LLL-reduced basis for a lattice $L$ in $\mathbb{R}^n$, and let $\tilde{b_1},\hdots,\tilde{b_n}$ be the Gram-Schmidt basis. Then we have

\begin{align*}
 &\|b_j\|^2 \leq 2^{i-1} \cdot \|\tilde{b}_i\|^2 \hspace{10mm}\text{ for } 1 \leq j \leq i \leq n \\
 &\|\tilde{b_1}\| \leq 2^{\frac{n-1}{4}} \cdot det(L)^{\frac{1}{n}} 
\end{align*}
\end{property}

\begin{property}
Let $L \in \mathbb{Z}^n$ be a lattice spanned by $B = \{b_1, \hdots, b_n\}$. The LLL algorithm outputs a reduced lattice basis $\{v_1,\hdots,v_n\}$ with

\[ \|v_i\| \leq 2^{\frac{n(n-1)}{4(n-i+1)}} \cdot det(L)^{\frac{1}{n-i+1}} \hspace{5mm} \text{ for } i = 1,\hdots,n\]

in time polynomial in $n$ and in the bit-size of the entries of the basis matrix $B$.
\end{property}


\section{Attacks}\label{attacks}

Attacks on RSA falls into two categories: the attacks on the \textbf{implementation} or the \textbf{mathematical attacks}. Over the years the mathematical cryptanalysis has proven to be hard and thus the cryptosystem is still considered as secure nowadays (march 2015). But what a researcher could find interesting is to attack a \textbf{relaxed} version of the RSA problem. What if we knew ``a part'' of the message, or what if we knew ``an approximation'' of one of the prime, or what if the private exponent was ``too small''...

% As an example let's see the simple Hadstad broadcast attack:

% Hadstad Broadcast Attack

% But what if m was not small, but we know m up to a small part

\section{Coppersmith}\label{coppersmith}

This survey is no replacement for the original papers of Coppersmith\cite{coppersmith} and Howgrave-Graham\cite{howgrave-graham}. If you want to get a real understanding of those techniques I also advise you to read the survey from May\cite{may}.

\subsection{Known modulus}\label{knownmodulus}

That being said, let's dig into Coppersmith's use of LLL to crack RSA. We'll first see one of the problem it solves and build it from there. Imagine that you know a part of the message: this is called the \textbf{Stereotyped Messages Attack}. For example you know that the Alice always sends her messages this way: ``the password is: cupcake''.

Let's say we know $m_0$ of the message $m = m_0 + x$. And of course we don't know $x$. We have \textbf{our problem} translated to the following equation:

\[ f(x) = (m_0 + x)^e - c = 0 \pmod{N} \]

Well. \textbf{Coppersmith} says we can solve this if $x$ and $e$ are small enough:

\begin{theorem}
Let $N$ be an integer of unknown factorization, which has a divisor $b \geq N^{\beta}$, $0 < \beta \leq 1$. Let $f(x)$ be a univariate monic polynomial of degree $\delta$ and let $c \geq 1$.\\
Then we can find in time $\mathcal{O}(c\delta^5log^9(N))$ all solutions $x_0$ of the equation

\[ f(x) = 0 \pmod{b} \hspace{2mm} \text{ with } \hspace{2mm} |x_0| \leq c \cdot N^{\frac{\beta^2}{\delta}} \]
\end{theorem}

In our case that would mean that for $c=1$ and $beta=1$ we could find a solution of our previous equation if $|x_0| \leq N^{\frac{1}{e}}$. And here we find something very similar to Håstad's Broadcast Attack.

To find the roots of a polynomial \textbf{over a ring of integers modulo} $N$ is a very \textbf{difficult} task, whereas we possess efficient tools to find roots of  polynomials \textbf{over the integers} (Berlekamp–Zassenhaus, van Hoeij, Hensel lifting...). Hence Coppersmith's intuition to look for such a polynomial:

\begin{tikzpicture}
\node [above] at (2,1) {$f(x_0) = 0 \pmod{N}$ with $|x_0| < X$};
\draw [<-,purple] (0,0) -- (0,1);
\node [below] at (0.6,0) {$g(x_0) = 0$ over $\mathbb{Z}$};
\end{tikzpicture}


But how can we go from $f$ to $g$ here? The theorem of \textbf{Howgrave-Graham} gives us a clue:

\begin{theorem}
Let $g(x)$ be an univariate polynomial with $n$ monomials. Further, let $m$ be a positive integer. Suppose that
\setcounter{equation}{0}
\begin{align}
&g(x_0) = 0 \pmod{N^m} \hspace{2mm} \text{ where } \hspace{2mm} |x_0| \leq X\\
&\|g(xX)\| < \frac{_{N^m}}{^{\sqrt{n}}}
\end{align}

Then $g(x_0)=0$ holds over the integers.
\end{theorem}

What Howgrave-Graham is saying is that we need to \textbf{find a polynomial} that shares the same root as our function $f$ but modulo $N^m$ and it has to have \textbf{``small'' coefficients} so that its norm would be ``small'' as well.\\

\begin{tikzpicture}
\node [above] at (2,4) {$f(x_0) = 0 \pmod{N}$ with $|x_0| < X$};
\draw [<-] (0,0) -- (0,4);
\node [below] at (0.6,0) {$g(x_0) = 0$ over $\mathbb{Z}$};
\draw [purple,<-] (0,1) -- (1,1);
\node [right] at (1.2,1.35) {$g(x_0) = 0 \pmod{N^m}$};
\node [right] at (1.2,.65) {$\|g(xX)\| < \frac{N^m}{\sqrt{n}}$};
\draw [purple,<-] (3,2) -- (3,4);
\end{tikzpicture}

Howgrave-Graham's idea is that we need to find this polynomial $g$ by \textbf{combining} polynomials who also have $x_0$ as roots. The more polynomials we can play with, the better. We will see later that it is very easy for us to create polynomials $f_i$ such that $f_i(x_0) = 0 \pmod{N^m}$. And that is the reason why we choose to find a polynomial over $N^m$ and not over $N$.\\

The \textbf{LLL reduction} has two properties that are useful to us:
\begin{itemize}
	\item{It only does \textbf{integer linear operations} on the basis vectors}
	\item{The \textbf{shortest vector of the output basis is bound} (as seen in \textbf{Property 1})}\\
\end{itemize}
The first point allows us to combine them to build a function that still has $x_0$ as root modulo $N^m$:

\[ g(x_0) = \sum^n_{i=1}a_i\cdot f_i(x_0) = 0 \pmod{N^m}\hspace{5mm} a_i \in \mathbb{Z} \]

The second point allows us to get Howgrave-Graham's second point ($\|g(xX)\| < \frac{_{b^m}}{^{\sqrt{n}}}$).\\

But first let's see how to \textbf{build the polynomials} $f_i$ (we will call them $g_{i,j}$ and $h_i$) we will build our $g(x_0) = 0$ with. Note that $\delta$ is the degree of $f$:

\begin{align*}
	g_{i,j}(x) &= x^j \cdot N^i \cdot f^{m-i}(x) \text{ for } i = 0,\hdots,m-1,\hspace{2mm} j=0,\hdots,\delta-1\\
	h_i(x) &= x^i \cdot f^m(x) \text{ for } i = 0,\hdots,t-1
\end{align*}

Those polynomials achieve two things:
\begin{itemize}
	\item{they have the \textbf{same root} $x_0$ but modulo $N^m$}
	\item{each iteration introduce a new polynomial, that allows us to build a \textbf{triangular} lattice (so that the determinant is easier to calculate)}\\
\end{itemize}

If you don't understand how they have the same root $x_0$ remember that since $f(x_0) = 0 \pmod{N}$ we know that $f(x_0) = k \cdot N$\\

Now we just have to create a lattice basis with $f_i(xX)$ as row vectors (because we want them to build a polynomial $g(xX)$ to test Howgrave-Graham second point).\\


Let's take a look at the \textbf{overview} again:\\

\begin{tikzpicture}
% 1
\node [above right] at (.5,10) {$f(x_0) = 0 \pmod{N}$ with $|x_0| < X$};
\draw [<-] (1,0) -- (1,10);
\node [below right] at (0.5,0) {$g(x_0) = 0$ over $\mathbb{Z}$};
% 2
\draw [<-] (1,1) -- (1.5,1);
\node [right] at (1.7,1.35) {$g(x_0) = 0 \pmod{N^m}$};
\node [right] at (1.7,.65) {$\|g(xX)\| < \frac{N^m}{\sqrt{n}}$};
\draw [<-] (3.5,2) -- (3.5,10);
% new 3
\draw [purple,->] (6,10) -- (6,9.5);
\node [below right] at (4,9.3) {generate $f_i$ s.t. $f_i(x_0) = 0 \pmod{N^m}$};

\draw [purple,->] (6,8.6) -- (6,7.8);
\node [below right] at (4,7.5) {$B = \begin{pmatrix}
  f_i(xX) \\
  \vdots  \\
  f_n(xX)
 \end{pmatrix}$};
 
\draw [purple,->] (6,5.5) -- (6,4.4);
\node [right] at (6.3,5) {LLL};

\node [below right] at (4,4.1) {$B' = \begin{pmatrix}
  b_1 = g(xX) \\
  b_2\\
  \vdots  \\
  b_n
 \end{pmatrix}$};
 
\draw [<-,purple] (3.5,3) -- (4,3);
\end{tikzpicture}\\

Now the shortest vector of $B'$ (the LLL-reduced basis) should be the coefficient vector of $g(xX)$. \\

As I said earlier, the LLL reduction allows us to achieve an \textbf{upper bound} on this shortest vector:

\[ \|b_1\| < 2^{\frac{n-1}{4}} \cdot det(L)^{\frac{1}{n}} \]\\

Now, to obtain Howgrave-Graham's second point on our $g$ ($\|g(xX)\| < \frac{_{b^m}}{^{\sqrt{n}}}$) we have to manipulate $g_{i,j}(xX)$ and $h_i(xX)$ to obtain a small enough determinant. This is the bound we wish to obtain on the determinant:

\[ det(L) < N^{m \cdot n}\]

And here's the determinant:

\[ det(L) = N^{\frac{1}{2}\delta m (m+1)}X^{\frac{1}{2}n(n-1)} \]

To do that we need to \textbf{tweak} $m$ and $t$ until we obtain the correct bounds. Note that the bound on the shortest vector of the reduced lattice basis is generous. That means that even if we don't correctly bound our determinant, we might find an answer.

\subsection{Any modulus}\label{anymodulus}

Coppersmith method is actually more general: it also works for unknown modulus.\\
For example, imagine the problem where we know an approximation of one of the prime. This attack is called \textbf{Factoring with High Bits Known}.



\section{Boneh-Durfee}\label{bonehdurfee}

This survey is no replacement for the original papers of Boneh and Durfee\cite{bonehdurfee} and Herrmann and May\cite{herrmannmay}.

We've seen how Coppersmith found a way of using lattices and the LLL algorithm to find small roots to particular univariate polynomials. What about problems that have two unknowns? Coppersmith gave an heuristic for finding roots of \textbf{bivariate polynomials} but left it at that. More recently, Boneh and Durfee have released papers on some RSA attacks that make use of the initial ideas of Coppersmith for finding small roots of bivariate polynomials.

Let's introduce the problem:

Boneh and Durfee are telling us we can, \textbf{most of the time} (they released a heuristic and not a theorem), successfully \textbf{factor} $\textbf{N}$ if the \textbf{private exponent $\textbf{d}$ is too small}. Precisely if $d < N^{0.292}$.\\

Recall how RSA works:
\begin{align*}
&e \cdot d = 1 \pmod{\varphi(N)}\\
\implies& e \cdot d = k \cdot \varphi(N) + 1\\
\implies& k \cdot \varphi(N) + 1 = 0 \pmod{e}\\
\implies& k \cdot (N + 1 - p - q) + 1 = 0 \pmod{e}
\end{align*}
Here the unknowns are $k$ and $(-p-q)$. We can write that problem as a polynomial with root $x_0$ and $y_0$:
\[ f(x,y) = x \cdot (A + y) \pmod{e} \]

Now we use \textbf{Coppersmith's heuristic for multivariate polynomials}. Coupled with \textbf{Howgrave-Graham's Theorem} for bivariate polynomials:

\begin{theorem}
Let $g(x)$ be an bivariate polynomial with at most $n$ monomials. Further, let $m$ be a positive integer. Suppose that
\setcounter{equation}{0}
\begin{align}
&g(x_0,y_0) = 0 \pmod{e^m} \hspace{2mm} \text{ where } \hspace{2mm} |x_0| \leq X \text{ and } |y_0| \leq Y\\
&\|g(xX,yY)\| < \frac{_{e^m}}{^{\sqrt{n}}}
\end{align}
Then $g(x_0,y_0)=0$ holds over the integers.\\
\end{theorem}

But the problem here is that \textbf{one polynomial is not enough} to get the roots of a bivariate equation. What we need are \textbf{two polynomials}, then we could use the \textbf{resultant} or a Gröbner basis to find the roots.

Coppersmith proposed to take \textbf{the two shortest vectors}, of the LLL-reduced basis, as polynomials. Let's take a look at what it should look from a distance:\\

\begin{tikzpicture}
% 1
\node [above right] at (.5,10) {$f(x_0, y_0) = 0 \pmod{e}$ with $|x_0| < X$ and $|y_0| < Y$};
\draw [<-] (1,0) -- (1,10);
\node [below right] at (0.5,0) {$g_1(x_0,y_0) = 0$ over $\mathbb{Z}$};
% new 1
\node [below right] at (0.5,-.6) {$g_2(x_0,y_0) = 0$ over $\mathbb{Z}$};
\draw [->] (1,-1.4) -- (1,-2.1);
\node [below right] at (0.5,-2.1) {$r(x) = resultant_x(g_1, g_2)$};
% 2
\draw [<-] (1,1) -- (1.5,1);
\node [right] at (1.7,1.35) {$g_1(x_0,y_0) = 0 \pmod{e^m}$ and $\|g_1(xX,yY)\| < \frac{e^m}{\sqrt{n}}$};
\node [right] at (1.7,.65) {$g_2(x_0,y_0) = 0 \pmod{e^m}$ and $\|g_2(xX,yY)\| < \frac{e^m}{\sqrt{n}}$};
\draw [<-] (3.5,2) -- (3.5,10);
% new 3
\draw [->] (6,10) -- (6,9.5);
\node [below right] at (4,9.3) {generate $f_i$ s.t. $f_i(x_0,y_0) = 0 \pmod{N^m}$};

\draw [->] (6,8.6) -- (6,7.8);
\node [below right] at (4,7.5) {$B = \begin{pmatrix}
  f_i(xX,yY) \\
  \vdots  \\
  f_n(xX,yY)
 \end{pmatrix}$};
 
\draw [->] (6,5.5) -- (6,4.4);
\node [right] at (6.3,5) {LLL};

\node [below right] at (4,4.1) {$B' = \begin{pmatrix}
  b_1 = g_1(xX, yY) \\
  b_2 = g_2(xX, yY)\\
  \vdots  \\
  b_n
 \end{pmatrix}$};
 
\draw [<-] (3.5,3) -- (4,3);
\end{tikzpicture}\\

And once we find the root $x_0$ of $r$ we can re-inject it in $g_1$ to find $y_0$.

\textbf{This doesn't always yield a solution}. For example, if the two polynomials $g_1$ and $g_2$ are not independent, the resultant will be zero.\\

\textbf{Boneh and Durfee} proposed a construction of the $f_i$ polynomials as follow:
\begin{align*}
	\text{for } k = 0,\hdots,m&:\\
	g_{i,k}(x) &= x^i \cdot f^k(x,y) \cdot e^{m-k} \text{ for } i=0,\hdots,m-k\\
	h_{j,k}(x) &= y^j \cdot f^k(x,y) \cdot e^{m-k} \text{ for } j = 0,\hdots,t
\end{align*}

They called the $g_{i,k}$ \textbf{x-shifts} and the $h_{j,k}$ \textbf{y-shifts}.\\

By using these polynomials to build the lattice, carefully balancing the variables so that the determinant of the triangular basis doesn't exceed $e^{mn}$, Boneh and Durfee showed that LLL successfuly yielded useful results if $d < N^{0.284}$.\\

To achieve their \textbf{improved results} of $d < N^{0.292}$, they showed that using a sublattice by \textbf{ignoring some of the y-shifts}, the bounds on the shortest vectors found by LLL were improved. Unfortunately by doing this we \textbf{lose the triangular structure} of the basis and computing the determinant of the new rectangular basis is tricky.

\textbf{Boneh and Durfee} developed the notion of \textbf{Geometrically progressive matrices} to handle these non-triangular lattice basis. Later \textbf{Blömer and May} took a different approach by noticing that some of the columns could be removed without affecting the determinant too much, that allowed the lattice basis to return to a triangular structure. Both those methods are quite difficult to manipulate and it's more recently that \textbf{Herrmann and May} found a clever and better way:\\

The \textbf{Unravelled Linearization} technique consists in \textbf{modifying} our initial polynomial $f$. Done cleverly this will modify the $f_i$ so that after removing the y-shifts, our sublattice basis will \textbf{directly be triangular}.

Herrmann and May propose to do the following \textbf{substitution} on $f$:

\[ f(x,y)=\underbrace{1 + xy}_u + Ax \pmod{e} \]

This leaves us with the \textbf{linear polynomial} $\bar{f}(u, x) = u + Ax$ (note the lexicographic order, $u$ before $x$) and a relation $xy = u - 1$.

The x-shifts are still constructed as usual:

\[ \bar{g}_{i,k}(u,x) = x^i \cdot \bar{f}^k \cdot e^{m-k} \text{ for } k = 0,\hdots,m \text{ and } i=0,\hdots,m-k \]

The y-shifts are \textbf{selected} so that using the previous relation $xy = u - 1$ we end up with a \textbf{triangular} lattice basis:

\[ \bar{h}_{j,k}(u,x,y) = y^j \cdot \bar{f}^k \cdot e^{m-k} \text{ for } j = 1,\hdots,t \text{ and } k=\left\lfloor\frac{m}{t}\right\rfloor\cdot j,\hdots,m \]

\newpage
\begin{thebibliography}{1}

\bibitem{chrispeikert} Chris Peikert {\em Lattices in Cryptography, Georgia Tech, Fall 2013: Lecture 2, 3}
\bibitem{coppersmith} Don Coppersmith {\em Finding Small Solutions to Small Degree Polynomials}
\bibitem{howgrave-graham} Nicholas Howgrave-Graham {\em Finding Small Roots of Univariate Modular Equations Revisited}
\bibitem{may} Alexander May {\em Using LLL-Reduction for Solving RSA and Factorization Problems}
\bibitem{bonehdurfee} Boneh and Durfee {\em Cryptanalysis of RSA with Private Key d Less Than $N^{0.292}$}
\bibitem{herrmannmay} Herrmann and May {\em Maximizing Small Root Bounds by Linearization and Applications to Small Secret Exponent RSA}


\end{thebibliography}

\end{document}